---
title: "Node 事件循环"
date: 2023-02-09T13:35:35+08:00
markup: pandoc
draft: false
categories:
- node
tags:
- node
---

JavaScript 是一门和事件循环结合非常紧密的语言，它最早出现在浏览器上，因为 JavaScript 为了保持 DOM 与操作相分离，同时协调浏览器上的各种资源，因而不得不有一个总线去处理，这个总线就是事件循环。 ES 标准并没有规定事件循环应该如何编写，因为这很明显取决于运行时，所以各个 Runtime 之间的事件循环存在较大的差别，比如说，之前浏览器和 Node 的事件循环机制就存在较大的差别。最新版的 Node 在事件循环上的表现，基本与浏览器类似了。

Node 的事件循环机制基于 libuv ，当你去阅读 Node 源码时，你会发现 Node 用的基本就是 libuv 默认的事件循环机制。可以说 Node 是 libuv 实践的一大例子。 Node 的事件循环与 libuv 没有本质的差别。

Node 的事件循环的顺序为：

1. 更新循环事件，判断队列是否存活。
2. 运行到期定时器。
3. 回调回调函数。
4. 运行 idle 句柄回调。
5. 运行 prepare 句柄回调。
6. Poll 进行 IO 循环。
7. 运行 check 句柄回调。
8. 回调关闭函数。

其中，最难被理解的是 idle 、 prepare 和 check 部分。这部分代码的主体结构是一样的，都是用宏生成的三个句柄。

idle 部分写入的回调将会在每次循环到达时调用，虽然它的名字叫 “idle” （空闲），但实际上是非常忙碌的，因此有人也提议叫“spin”。

prepare 和 check 部分其实相对类似，那么 idle 、 prepare 和 check 有什么用？

idle 、 prepare 和 check 在事实上组成而观察者模式，由 idle 进行监听，比如说监听到需要 IO 了，就交给 prepare 进行准备，此时 prepare 将会准备好回调，并准备好下一步的 poll 。如果 poll 成功了，将会在 check 时挂载上回调函数，等到下一个循环 pending 时调用。 libuv 在阐述这部分的时候，讲得并不详细，因为这部分内容在它过去的“老父亲” —— libev 身上。

至于 libev 为什么要分阶段，这就涉及到 libevent 和 libev/libuv 设计思想上的区别， libevent 给予了编程人员更大的编程自由，但同时也大大增加了处理事件循环时的心智负担。 libev 和 libuv 则简化了这个模型，而 libuv 进一步简化，放弃了优先级，改为顺序处理。

从 Node 的事件循环模型我们可以发现一个问题，就是在 Node 的设计下，我们很难对 IO 进行扩展，因为这部分被 libuv 封死了，由于封装得太好，反而没有太多底层的空间，即使你用 C++ 也难改变。由于 libuv，使得 Node 的并发只能考虑多进程，而多个进程沟通其实非常困难，且效率低下，充分利用 CPU 也只能在一个非常低的层次，只能说 Node 在大型应用上面潜力确实不高。
